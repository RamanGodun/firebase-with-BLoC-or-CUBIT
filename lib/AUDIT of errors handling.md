⚠️ Виявлені Проблеми та Недоліки:














3. ResultHandler / ResultHandlerAsync
	•	⚠️ Додаткова обгортка чи необхідність?: Класи ResultHandler та ResultHandlerAsync покликані спростити обробку результатів операцій (успіх/невдача). Вони інкапсулюють типові дії над Either-результатами, але виникає питання, чи не дублюють вони наявний функціональний підхід і чи використовуються послідовно по всьому проєкту.
	•	Коментарі: Ідея ResultHandler полягає в тому, щоб позбутися повторення шаблону .fold(failure, success) у кожному випадку, натомість делегувати це спеціальній утиліті. Теоретично, це робить код більш декларативним і читається як “обробити результат за таким сценарієм…”. Якщо вся команда дотримується використання ResultHandler, то підхід буде уніфікованим: наприклад, кожен UseCase може повертати Either, а UI-логіка через ResultHandler вирішує, що робити з помилкою (логувати, показати) і з успішними даними (відобразити). Однак, якщо у деяких місцях розробники все ж безпосередньо працюють з Either або використовують інші техніки, це може призвести до фрагментації стилю. З точки зору OCP, введення нових сценаріїв обробки вимагатиме модифікації ResultHandler, тому важливо розуміти, які переваги він дає. Наразі видно певне дублювання логіки: багато що з того, що робить ResultHandler, можна виконати стандартними засобами (Either.fold або через розширення). Тому рекомендується проаналізувати необхідність цих обгорток. Якщо вони привносять реальну користь (наприклад, автоматично логують помилки або сповіщають UI через сервіс), варто документувати їх і використовувати скрізь. Якщо ж ні – можна спростити систему, відмовившись від зайвого рівня абстракції, що полегшить підтримку коду в довгостроковій перспективі.

Пропозиція:

ResultHandler vs Either
Паралельне використання ResultHandler та прямого .fold (Either)
Дублювання підходів, підвищена складність підтримки, ризик неузгодженості в коді
Вибрати єдиний стиль обробки результатів: або повсюдно застосувати ResultHandler (з чітким описом його призначення), або спростити систему, відмовившись від нього на користь стандартного оброблення через Either.











6. UI Integration (OverlayNotificationService)
	•	⚠️ Стратегія відображення помилок через overlay: Сервіс OverlayNotificationService забезпечує показ повідомлень про помилки на UI-рівні (імовірно, у вигляді вспливаючих нотифікацій поверх інтерфейсу). Це означає, що система централізовано керує тим, як користувач бачить помилки. Рішення в цілому правильне, але потребує впевнитись у гнучкості та коректній інтеграції з потоками UI.
	•	Коментарі: Використання OverlayNotificationService дозволяє винести логіку відображення помилок з окремих екранів у єдине місце. Наприклад, замість того щоб у кожному виджеті вручну викликати ScaffoldMessenger чи інший механізм, можна довірити цьому сервісу показ стандартного toast/snackbar з текстом помилки. В ідеалі, виклик цього сервісу відбувається на Presentation-рівні (в блоках/cubit-ах або в загальному observer), коли з’являється новий Failure, і не зачіпає Domain-рівень (тобто домен нічого не знає про те, як саме показуються помилки). Важливо перевірити, що цей принцип дотримано. Поточна інтеграція, судячи з усього, ще налаштовується: пов’язані з Consumable помилки у стані мають привести до виклику OverlayNotificationService один раз. Треба впевнитись, що, наприклад, у методі build() UI або в обробнику станів Bloc при наявності невикористаного Failure викликається OverlayNotificationService з переданим Failure.translationKey. З точки зору гнучкості, варто зазначити, що жорстко заданий overlay-підхід поки не дозволяє легко переключитися на інший спосіб (скажімо, показувати діалогове вікно для критичних помилок або взагалі відображати помилку іншим чином в контенті сторінки). На даний момент це не критично і може відповідати вимогам продукту. Проте у перспективі, щоб система була розширюваною, можна передбачити можливість конфігурації OverlayNotificationService або створити інтерфейс INotificationService, різні імплементації якого відповідають за різні стилі повідомлень. Підсумовуючи, інтеграція з UI є, користувач не залишиться без зворотного зв’язку про помилку – за це ✅, але поки що ставимо ⚠️ через обмежену кастомізацію і необхідність уважно синхронізувати її роботу з Consumable-патерном.

Пропозиція :

OverlayNotificationService
Фіксований спосіб UI-нотифікації (тільки overlay)
Обмежена гнучкість: важко змінити стиль повідомлень або використати інший підхід для певних помилок без зміни коду сервісу
Розширити можливості сервісу: продумати параметри або різні реалізації INotificationService. Це дозволить, при потребі, показувати помилки альтернативно (наприклад, модальним діалогом для критичних випадків) без рефакторингу основної логіки.