




⚠️ Виявлені Проблеми та Недоліки:








✅ 2. Виправити translationKey як єдиний стандарт
Стан:
Десь ти вказуєш Failure(key: ...), хоча конструктор чекає translationKey.

Рішення:
	•	Перевір усі місця, де створюється Failure(...), і уніфікуй використання ключа translationKey.


FailureMapper / Failure
Невідповідність назви параметра translationKey (key замість потрібного) при створенні Failure
Код не компілюється, локалізація повідомлення не підставляється
Виправити сигнатури: використовувати правильний named-параметр translationKey у конструкторах Failure (замість неіснуючого key).







5. Consumable / Ephemeral Events
	•	⚠️ Реалізація одноразових подій з нюансами: Впроваджено механізм Consumable для маркування подій, що мають бути оброблені лише один раз (наприклад, показ повідомлення про помилку). Це правильна ідея для уникнення повторного відображення однієї й тієї ж помилки при пересозданні виджету, але поточна реалізація має деякі проблеми у використанні.
	•	Коментарі: Клас Consumable працює як обгортка, що зберігає Failure і позначає, чи вже “спожито” цю подію. Таким чином, коли, скажімо, стан екрану містить Consumable<Failure> error, виджет може при побудові перевірити, чи є невикористана помилка, відобразити її (наприклад, викликати OverlayNotificationService), а потім помітити її як використану. Це попереджає ситуацію, коли при повторному побудові того ж стану користувач знов побачить старе повідомлення. Однак аналіз коду показав, що при інтеграції виникли труднощі: у деяких місцях Consumable<Failure> передається туди, де очікується просто Failure – що спричиняє помилки типів (компіляція не проходить, властивості Failure недоступні безпосередньо через Consumable тощо). Це свідчить про те, що патерн ще не до кінця уніфікований у коді. Необхідно чітко визначити контракт між станом і UI: або UI-компоненти мають вміти розпаковувати Consumable, або ж стан має надавати зручний метод для отримання внутрішнього Failure. Після виправлення цих моментів (наприклад, викликати failure = consumable.value перед передачею в виджет або реалізувати метод на кшталт consumable.consume(), що повертає Failure), механізм запрацює як слід. Загалом, Consumable – корисний інструмент для одноразових подій, але його потрібно використовувати послідовно, щоб вся команда розуміла, як з ним працювати (можливо, додати коментарі чи гайд у документації проекту). В поточному вигляді ставимо ⚠️ через необхідність виправлень, але проблема розв’язувана.

Пропозиція:

Consumable (UI інтеграція)
Consumable<Failure> використовується як Failure напряму (невірний тип)
Помилка компіляції; повідомлення про помилку не відображається в UI
Уніфікувати підхід: розпаковувати Failure із Consumable перед передачею в UI або змінити параметри методів UI, щоб приймати Consumable. Забезпечити споживання події після відображення, щоб уникнути повторного показу.


Рішення:
	•	Усі UI-компоненти мають викликати щось на кшталт:
final failure = state.error.consume();
if (failure != null) {
  _overlayService.show(failure.translationKey);
}

	•	Заборонити прямий доступ до .value без перевірки .consumed.








3. ResultHandler / ResultHandlerAsync
	•	⚠️ Додаткова обгортка чи необхідність?: Класи ResultHandler та ResultHandlerAsync покликані спростити обробку результатів операцій (успіх/невдача). Вони інкапсулюють типові дії над Either-результатами, але виникає питання, чи не дублюють вони наявний функціональний підхід і чи використовуються послідовно по всьому проєкту.
	•	Коментарі: Ідея ResultHandler полягає в тому, щоб позбутися повторення шаблону .fold(failure, success) у кожному випадку, натомість делегувати це спеціальній утиліті. Теоретично, це робить код більш декларативним і читається як “обробити результат за таким сценарієм…”. Якщо вся команда дотримується використання ResultHandler, то підхід буде уніфікованим: наприклад, кожен UseCase може повертати Either, а UI-логіка через ResultHandler вирішує, що робити з помилкою (логувати, показати) і з успішними даними (відобразити). Однак, якщо у деяких місцях розробники все ж безпосередньо працюють з Either або використовують інші техніки, це може призвести до фрагментації стилю. З точки зору OCP, введення нових сценаріїв обробки вимагатиме модифікації ResultHandler, тому важливо розуміти, які переваги він дає. Наразі видно певне дублювання логіки: багато що з того, що робить ResultHandler, можна виконати стандартними засобами (Either.fold або через розширення). Тому рекомендується проаналізувати необхідність цих обгорток. Якщо вони привносять реальну користь (наприклад, автоматично логують помилки або сповіщають UI через сервіс), варто документувати їх і використовувати скрізь. Якщо ж ні – можна спростити систему, відмовившись від зайвого рівня абстракції, що полегшить підтримку коду в довгостроковій перспективі.

Пропозиція:

ResultHandler vs Either
Паралельне використання ResultHandler та прямого .fold (Either)
Дублювання підходів, підвищена складність підтримки, ризик неузгодженості в коді
Вибрати єдиний стиль обробки результатів: або повсюдно застосувати ResultHandler (з чітким описом його призначення), або спростити систему, відмовившись від нього на користь стандартного оброблення через Either.











6. UI Integration (OverlayNotificationService)
	•	⚠️ Стратегія відображення помилок через overlay: Сервіс OverlayNotificationService забезпечує показ повідомлень про помилки на UI-рівні (імовірно, у вигляді вспливаючих нотифікацій поверх інтерфейсу). Це означає, що система централізовано керує тим, як користувач бачить помилки. Рішення в цілому правильне, але потребує впевнитись у гнучкості та коректній інтеграції з потоками UI.
	•	Коментарі: Використання OverlayNotificationService дозволяє винести логіку відображення помилок з окремих екранів у єдине місце. Наприклад, замість того щоб у кожному виджеті вручну викликати ScaffoldMessenger чи інший механізм, можна довірити цьому сервісу показ стандартного toast/snackbar з текстом помилки. В ідеалі, виклик цього сервісу відбувається на Presentation-рівні (в блоках/cubit-ах або в загальному observer), коли з’являється новий Failure, і не зачіпає Domain-рівень (тобто домен нічого не знає про те, як саме показуються помилки). Важливо перевірити, що цей принцип дотримано. Поточна інтеграція, судячи з усього, ще налаштовується: пов’язані з Consumable помилки у стані мають привести до виклику OverlayNotificationService один раз. Треба впевнитись, що, наприклад, у методі build() UI або в обробнику станів Bloc при наявності невикористаного Failure викликається OverlayNotificationService з переданим Failure.translationKey. З точки зору гнучкості, варто зазначити, що жорстко заданий overlay-підхід поки не дозволяє легко переключитися на інший спосіб (скажімо, показувати діалогове вікно для критичних помилок або взагалі відображати помилку іншим чином в контенті сторінки). На даний момент це не критично і може відповідати вимогам продукту. Проте у перспективі, щоб система була розширюваною, можна передбачити можливість конфігурації OverlayNotificationService або створити інтерфейс INotificationService, різні імплементації якого відповідають за різні стилі повідомлень. Підсумовуючи, інтеграція з UI є, користувач не залишиться без зворотного зв’язку про помилку – за це ✅, але поки що ставимо ⚠️ через обмежену кастомізацію і необхідність уважно синхронізувати її роботу з Consumable-патерном.

Пропозиція :

OverlayNotificationService
Фіксований спосіб UI-нотифікації (тільки overlay)
Обмежена гнучкість: важко змінити стиль повідомлень або використати інший підхід для певних помилок без зміни коду сервісу
Розширити можливості сервісу: продумати параметри або різні реалізації INotificationService. Це дозволить, при потребі, показувати помилки альтернативно (наприклад, модальним діалогом для критичних випадків) без рефакторингу основної логіки.